\chapter{System Design}\label{chapter:general_design_decisions}

\section{Core Design Decisions}
The Framework is designed to be distributed in nature with the concepts of Actors~[\autoref{sec:actorProgramming}]. It should follow the standard actor programming concept and provide inherently distributed nature to the applications built on top of it. The framework itself should be built using the concept of ‘message-passing’~[\autoref{sec:messagePassing}] to alleviate any possibility of concurrency issues, thus thread-safe.

\begin{itemize}
  \item The framework may not guarantee the delivery of a message.
  \item All the messages sent by the framework will be based on ‘fire and forget’ concept.
  \item A message shall be delivered at most once.
  \item A message should always be routed through Message Queuing System, even though the target isolate may belong to same isolate system in the same logical or physical node.
  \item Feeding of message to an isolate should be based on pull mechanism, not push mechanism.
  \item Exceptions thrown at child isolates shall be handled by a ‘spawnee’ of that isolate. Thus implementing the idea of supervision and “let it crash” ideology[~\autoref{sec:letItCrash}].
\end{itemize}

\section{The Framework}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{figures/componentDiagram}
  \caption[architecture]{Architecture of the framework}
  \label{fig:architecture}
\end{figure}


The framework comprises of an Isolate System, a Registry, a Message Queuing System, a Message Broker System and an Activator. The \autoref{fig:architecture} depicts the general overview of different components and sub-components of the framework.

  \subsection{Isolate System}
  An Isolate System is analogous to an actor system. Just as an actor system consists of a group of actors working together, an isolate system is composed of a group of ‘Worker’ isolates working closely. It consists of different hierarchies which forms a logical organizational-like structure. The top level isolate is the Isolate System itself and the bottom most are the ‘Worker’ isolates.

  A ‘Bootstrapper’ in physical node can start up several Isolate Systems. Nevertheless, a logical Isolate System is not limited to a single physical node. The ‘Worker’ isolates spawned by an isolate system can be distributed across several remote systems.

  Each isolate system has its unique id, which is a \acrshort{uuid}. It is generated when the isolate system is bootstrapped. For bootstrapping, an isolate system needs the WebSocket address of Message Queuing System, and a ‘name’ for itself. The name is simply an alias, and should not be confused with the unique id as another isolate system with the same name can exist in other nodes but the unique id is exclusive for a particular instance of an isolate system.

  The bootstrapping of an isolate system includes: generating a new id which is unique for itself, opening up a ‘ReceivePort’, and connecting to a ‘Message Queuing System’. After opening up a ‘ReceivePort’, the isolate system starts listening on that port for messages so that it can receive incoming messages from ‘Controller’. While connecting to the Message Queuing System, if a connectin could not be established, it simply keeps on retrying at certain interval. Furthermore, should the connection be lost at any time after being connected with the MQS, the Isolate System automatically keeps on trying to re-establish the connection at regular interval. Since, the connection to MQS takes place asynchronously, the isolate system simply moves forward and spawns a controller, regardless of the establishment of connection with the MQS.

  \subsubsection{Adding Worker Isolates to The Isolate System}
  As an isolate system is a top level isolate, it spawns a Controller. The Controller spawns one or several Routers and each Router spawns Worker isolates.

  When an isolate system is first initialized, it is an empty system without any Workers running in it. The Workers can be added with appropriate load balancer once the isolate system has been initialized. The ‘addIsolate’ function can be used to startup isolates into the system. It requires following arguments:
  \begin{description}
    \item{\itshape{name}} \textendash{} A name for pool of isolates. A deployed isolate has its own name but overall the name is concatenated with the name of isolate system to denote the hierarchy. For instance, an isolate with name ‘account’ becomes ‘bank/account’ where ‘bank’ is the name of the isolate system.
    \item{\itshape{sourceUri}} \textendash{} The location of the source code from which the isolate shall be spawned. The path can either be absolute path to the local file system or the full http or https URI.
    \item{\itshape{workersPaths}} \textendash{} List of destinations where each of the isolates should be spawned. To spawn locally, ‘localhost’ should be used, whereas to spawn in remote node, WebSocket path like: “ws://192.168.2.9:42042/activator” should be used. The number copy of isolates that should be spawned is determined by the length of this list. If multiple copies of isolates should be spawned in a node, the location can be repeated. For instance [“localhost”, “localhost”] results in spawning of two identical isolates in local machine which is load balanced by the type of specified router.
    \item{\itshape{routerType}} \textendash{} The type of load balancing technique that one would like to use to effectively distribute incoming messages. By default, the framework, provides three types of routers: Round-Robin, Random and Broadcast. If the developer wants to use his own customized load balancer instead of using the options provided by the framework, the absolute path to the location of source code, which can also be a remote URI, of the custom router implementation can be provided.
    \item{\itshape{hotDeployment}} \textendash{} This argument is optional and is set to ‘true’ by default. Setting it to ‘true’ enables continuous monitoring of the source code. If any change in source code is identified, the  instances of isolates, spawned by this ‘addIsolate’ function, in current isolate system will be restarted, without the need of redeploying the system.
    \item{\itshape{args}} \textendash{} Custom additional arguments to be passed into each instance of spawned isolate. This argument is also optional and can be safely ignored.
  \end{description}

  \subsubsection{Message Handling in The Top Level Isolate System}
  Typically, a message in an isolate system can arrive from three sources: Message Queuing System via WebSocket, Controller via ReceivePort or Bootstrapper via direct function call. As Dart is a single threaded programming language [~\autoref{sec:isolates}], only one message is handled at a time.
  A Message Queuing System sends the data over WebSocket in JSON string format, which should be deserialized to Map data type before further processing. As the received message contains the queue name from which it is dequeued, the name of the queue is then parsed and transformed to name and address of the corresponding isolate. The message is then forwarded to the Controller that this instance of the isolate system has spawned.
  The messages arriving from Controller is either a dequeue requests or a message that should be sent to the Message Queuing System for enqueuing. The dequeue requests are sent from the isolates that have completed certain task and are ready to accept another message. For the dequeue requests, the sender of the message is identified, which is used to figure out the corresponding name of the queue name. Then the pull request to dequeue from that queue is forwarded to MQS via open WebSocket port. For the messages that are supposed to be delivered to another isolate, the name of the target isolate is used to figure out the name of the queue and then sent to the MQS for enqueuing.
  The ‘Bootstrapper’ of a node that creates an isolate system can send messages to isolate system by directly invoking the functions provided by the isolate system. The bootstrapper can request the information about the isolates this instance of isolate system is running. For which, the isolate system delegates the message to its controller and waits asynchronously for the response from the controller. The request, to fetch a list of running worker isolates, is triggered when a user sends the request to view details of an isolate system via a web interface or via RESTful web service provided by the ‘Registry’~\autoref{sec:registry}.
  Another type of message is the message to terminate a worker isolate, which is also forwarded to the controller as the isolate system does not directly manage the running worker isolates. Thus, the message is forwarded to the controller which is next in the hierarchy. In contrast, when the shutdown command for the isolate system is triggered via web or REST interface, the isolate system closes all the open ports including WebSocket ports and ReceivePorts, and then wait for the ‘Garbage Collector’ to and clean up the memory reserved by it.

  \subsubsection{Controller}
  Every Isolate System has a single controller, which is spawned by the top level isolate of an isolate system. A controller stays idle until it receives a message to create an isolate. Basically, a controller spawns and manages all the ‘Routers’ of an isolate system. Additionally, a controller takes care of ‘hot deployment’ feature for which it spawns a ‘FileMonitor’ for each Router if the feature is enabled. When a RESTART message is received from a FileMonitor, the controller sends a RESART\textunderscore{}ALL message to the designated Router, which restarts all the Worker isolates the Router has spawned.
  A controller is also responsible for replying to the query of list of isolates an isolate system is running. It achieves this by keeping a detailed record of each Router and number of Worker isolates each Router is handling, which is updated as soon as an isolate is killed or a new isolate is added.
  As a Controller is the ‘spawner’ of Routers and the ‘spawnee’ of the top level isolate, it forwards the messages as well as dequeue requests coming from Routers to the top level isolate of an isolate system.

  \subsubsection{Router}
  A router is spawned by a controller. The router creates and is responsible for a group of identical Workers isolates. Since an isolate is single threaded, creation of multiple instances of an isolate is desirable for concurrency. When a message arrives in a router from a controller, the router, based on its defined routing policy, delegates the message to one of the worker isolates. The routing policy can be chosen at the time of deployment of a worker isolate.
  A router uses a routing policy to distribute message among the group of isolates it is handling. The default routing policies that are available in the framework are:

  \begin{description}
    \item{Round Robin Router} Messages are passed in round-robin fashion to the Worker Isolates. For instance, if there are three isolates A, B and C. The first message goes to A, next one goes to B and the next one after that goes to C. The messages that comes after are delegated again to A, then B then C and so on.

    \item{Random Router} Randomly picks an isolate and the message is passed to that Worker Isolate.

    \item{Broadcast Router} Replicates and sends message to all Worker isolates.
  \end{description}

    In addition the available routing policies of the framework, it is also possible to add new Routing technique by simply extending the ‘Router’ class which require ‘selectWorker’ function to be overridden and implemented. The overridden ‘selectWorker’ function may either return a list of Workers or a single Worker. The ability to implement custom router opens up possibilities for numerous load balancing techniques. For instance, a simple multicasting router that replicates a message only to the Workers that are spawned locally can be implemented by selecting such Workers using their deployment paths and returning them as a ‘List’.
    As the router manages the Worker isolates it has spawned, it is responsible for effectively terminating, restarting the Worker isolates. It also buffers the messages that might arrive while the workers are not yet ready to accept the messages; like during the creation of Worker isolates or while restarting them.
    If a router does not receives any message from the Worker for a certain amount of time, the Router sends a PING message to check if the Worker isolate is alive and ready to accept more messages. If the Worker isolate responds with a PONG message, the router sends a request to fetch messages to controller. This mechanism is present in the framework to prevent the ‘starvation’ for a Worker isolate in case the dequeue message, that might have been sent earlier, could not reach the Message Queuing System because of a network issue or unavailability of MQS.

  \subsubsection{Worker}
  The Worker Isolate of the framework is an abstract class, which first ‘unwraps’ the messages that arrives from the Router. Before forwarding message to the child class, that extends this abstract class, the Worker Isolate first collects the sender and replyTo headers of the message. The Worker class then makes it available for the implemented instance. By ‘unwraping’ the messages that is encapsulated by various headers, the abstract Worker class makes sure that the message is delivered to the target implementation of Worker Isolate in original and intended form.
  The ‘send’, ‘reply’, ‘ask’ functions are also provided by this abstract Worker class which automatically adds headers with information of sender and receiver in proper format to the message.
  To extend the ‘Worker’ isolate, one must implement ‘onReceive’ function which handles incoming messages and carry out the business logic tasks. However, if a task is too complex, the Worker isolate can divide the tasks into subtasks and spawn temporary isolates to carry out those subtasks concurrently. The temporary isolates can be terminated once the subtask has been carried out.

  \subsubsection{Proxy}
  A ‘Proxy’ is the special type of a Worker. When a Worker isolate is supposed to be spawned in remote node, the Router instead first spawns a Proxy isolate in local node. Once the Proxy isolate is spawned, it connects to the ‘IsolateDeployer’ in remote node where the Worker Isolate is intended to be spawned. After establishing connection over a WebSocket with IsolateDeployer of remote node, the proxy Isolate forwards the request to spawn an isolate to the IsolateDeployer. After successful spawning of isolate in remote node, the proxy isolate simply forward the messages that is sent to it by the spawner Router. Each ‘Proxy’ worker maintains a separate WebSocket connection with an ‘IsolateDeployer’.
  <Insert a diagram here>

  \subsubsection{FileMonitor}
  FileMonitor is also a Worker Isolate. If the ‘Hot Deployement’ flag for an isolate is set while spawning, a ‘FileMonitor’ for that isolate is spawned by the Controller. The spawned ‘FileMonitor’ monitors the md5 checksum of the source code from where the Worker Isolate was spawned. If the file is changed, it simply sends the RESTART command to the controller, which eventually forwards it to the target Router which restarts all of its child isolates.

\subsection{The Registry}
The Isolate Registry is a central node where other nodes, with Bootstrappers running, connect and register themselves. The registry simply keeps the record of the connected nodes and queries them about the running isolate systems when required. The registry provides RESTful API and a web interface~/footnote{the web interface can be opted out as it is started separately} through which one can have an overview of the full system and manage the deployments of the isolate systems as well as individual isolates.

The basic tasks that a Registry carries out are:
\begin{itemize}
  \item Bootstrap an isolate system, during runtime, in local or remote virtual machine
  \item Provide a way to deploy, update or remove an ‘isolate system’
  \item Return information about the isolate systems running isolates by querying the individual isolate systems of a node
\end{itemize}

  \subsubsection{RESTful API of Registry}
  \label{subsec:restApi}
  The registry provides a REST API to perform the operations on the connected nodes. One can send a ‘GET’ request to the Registry to fetch the list of the nodes that are connected to the Registry. And then use that list to deploy an isolate system or add an isolate to already deployed system by sending ‘POST’ request.
  \begin{itemize}
  \item GET list of connected nodes
  \item GET details of the running isolate systems on the node
  \item POST command to deploy an isolate system
  \item POST command to shutdown an isolate system
  \item POST command to kill a particular isolate pool
  \end{itemize}

\paragraph{An example of using RESTful API to deploy an isolate system in a node}

\begin{description}
  \item{GET request to fetch a list of connected systems}\\
  Request: ‘GET \url{http://54.77.239.254:8000/registry/system/list}’\\
  Response: \\
  Status Code: 200 OK\\
  Body:
  \begin{lstlisting}[language=json,firstnumber=1]
    [
      {
        "bootstrapperId": "266393094",
        "ip": "54.77.239.244",
        "port": "50189"
      },
      {
        "bootstrapperId": "12133208",
        "ip": "54.77.239.243",
        "port": "50192"
      }
    ]
  \end{lstlisting}

  \item{POST request to deploy an isolate system}\\
  Request: ‘POST \url{http://54.77.239.254:8000/registry/deploy}’
  \begin{lstlisting}[language=json,firstnumber=1]
    {
      "bootstrapperId" : "266393094",
      "action": "action.addIsolate",
      "messageQueuingSystemServer": "ws://54.77.239.200:42043/mqs",
      "isolateSystemName" : "sampleSystem",
      "isolateName" : "consumer",
      "uri" : "http://54.77.239.221/sampleSystem/bin/Consumer.dart",
      "workersPaths" : ["localhost", "ws://54.77.239.243:42042/activator"],
      "routerType" : "random",
      "hotDeployment" : true
    }
  \end{lstlisting}
  Response: \\
  Status Code: 200 OK\\
\end{description}

\paragraph{An example of using RESTful API to fetch details of an isolate system}
  \begin{description}
    \item{POST request to get details of an isolate system}\\
    Request: ‘POST \url{http://54.77.239.254:8000/registry/system/266393094}’
    \begin{lstlisting}[language=json,firstnumber=1]
    {
      "mysystem": [
        {
          "id": "sampleSystem/consumer",
          "workerUri": "http://54.77.239.221/sampleSystem/bin/Consumer.dart",
          "workersCount": 2,
          "workersPaths": [
            "localhost",
            ws://54.77.239.243:42042/activator"
          ],
          "routerType": "random",
          "hotDeployment": true
        }
      ]
    }
  \end{lstlisting}
  \end{description}

\paragraph{An example of terminating an Isolate in isolate system}
  \begin{description}
    \item{POST request to terminate an isolate of an isolate system}\\
    Request: ‘POST \url{http://54.77.239.254:8000/registry/system/266393094}’
    \begin{lstlisting}[language=json,firstnumber=1]
      {
        "bootstrapperId" : "266393094",
        "isolateSystemName" : "sampleSystem",
        "isolateName" : "consumer"
      }
    \end{lstlisting}
  \end{description}

\paragraph{An example of terminating an isolate system}
  \begin{description}
    \item{POST request to terminate an isolate of an isolate system}\\
    Request: ‘POST \url{http://54.77.239.254:8000/registry/system/266393094}’
    \begin{lstlisting}[language=json,firstnumber=1]
      {
        "bootstrapperId" : "266393094",
        "isolateSystemName" : "sampleSystem"
      }
    \end{lstlisting}
  \end{description}

The registry does not need to persist any data as all the information about isolate systems are queried and generated “on the fly”.

  \subsubsection{The Web Interface for the Registry}
  The deployment of isolates can also be managed by using a web interface provided by the Registry. The Web Interface should be started up separately in a different port. The Web Interface, internally communicates with the Registry via the REST API~[\ref{subsec:restApi}] which is exposed by the Registry.
  <A Screenshot here or in Appendix>

\subsection{Message Queuing System (MQS)}
  Since, the basis of this system is message passing, the Message Queuing System is an important component of this framework. The Message Queuing System is an isolate that fetches messages from message broker system and dispatches to respective isolate of the isolate system. Whenever a new isolate system starts up, the isolate system opens up a new WebSocket connection with the Message Queuing System. The message exchange between the Isolate System and MQS takes place via the WebSocket connection. A header with the unique-id of an isolate system is added to the message as soon as it is received from an isolate system to identify origin of the message. If the message is was sent for enqueuing the header is ignored and simply the message with destination queue is forwarded the ‘Enqueuer’ isolate. Whereas, if the message is a dequeue request, the unique-id of the isolate system is also forwarded to a ‘Dequeuer’ isolate. The unique-id of isolate system used to identify the exact port through which the request arrived. Thus, making sure that the dequeued message is sent to the correct requester. This is especially useful if a cluster of identical isolate systems is running on different nodes.
  The Message Queuing System needs to be started up separately with command line arguments to connect to message broker system. The required command line arguments are ip address, port, username and password to connect to Message Broker System. The ‘prefetchCount’ is an optional argument which defaults to 1, if not provided explicitly. A ‘prefetchCount’ is a Quality of Service header for Message Broker System which allows a subscriber of a queue to hold the amount of unacknowledged messages as defined in prefetchCount.

** Passing of sockets to isolates is not possible, so the main isolate has to pipe all the input/output data.
in this case MQS is the main isolate which has to handle all incoming and outgoing messages.

  \subsubsection{Enqueuer}
  Enqueuer is a separate isolate. A Message Queuing System has only one enqueuer, which basically receives message from the MQS and sends message to message broker system \textendash{} RabbitMQ[~\ref{sec:rabbitmq}] via STOMP~[\ref{sec:stomp}] protocol.

  \subsubsection{Dequeuer}
  As opposed to Enqueuer, a Message Queuing System maintains each dequeuer for each topic, which corresponds to the each Router running in the isolate system. Whenever a message arrives from a new isolate, a new dequeuer isolate is spawned by the MQS. The new dequeuer then subscribes to a new message queue in the message broker system via STOMP~[\ref{sec:stomp}] protocol. If the queue did not exist in the message broker system, a new queue is automatically created. If a dequeuer is idle for too long, i.e. if the Dequeuer isolate has not received any dequeue requests for certain interval\footnote{by default the timeout is 10 seconds}, then the Dequeuer isolate for that particular queue is shutdown. Nevertheless, as soon as a request for dequeue is received by MQS, a new Dequeuer is spawned, if one does not exists yet.
  The dequeuer subscribes messages from Message Broker System with such options that the new messages do not arrive to the subscriber unless previously dequeued messages have been acknowledged. This throttles the flow of messages from message broker system and keeps the itself and the isolates from being overwhelmed by large number of messages, which might induce ‘out of memory’ issues.
  Messages in dequeuer keeps on arriving as long as there are messages in the queue and the messages are being acknowledged. The messages that are in buffer of dequeuer stay in unacknowledged unless they are flushed and sent out to the requesting isolate of an isolate system. As soon as a message is acknowledged the dequeuer receives another message from the message broker.

  \subsubsection{Multiple Instances of MQS}
  It is possible for a system to have multiple Message Queuing Systems for scaling up the system. In case there are multiple MQS and if there are multiple identical isolate systems connected to different MQS, each MQS will have a Dequeuer which subscribes to same queue. Nevertheless, a message is dispatched by the message broker system to only one of the dequeuers and it is distributed in round robin fashion. Thus messages are fairly distributed among the subscribers.

\subsection{Activator}
  An activator simply starts up two isolates: a Systembootstrapper and an IsolateDeployer. Every node that is supposed to be running an Isolate System or become a part of Isolate System by running isolates must be running an Activator. The Activator must be passed the WebSocket address of the Registry as a command line argument. Nevertheless, starting up of SystemBootstrapper and IsolateDeployer separately is also possible.

  \subsubsection{SystemBootstrapper}
When a SystemBootstrapper is started, it registers itself to the ‘Registry’ via a WebSocket connection. The path of the WebSocket connection is either forwarded from the Activator that spawned SystemBootstrapper. If a SystemBootstrapper is started separately then the path of the Registry can be passed as a command line argument.

  \subsubsection{IsolateDeployer}
An Isolate Deployer starts up a Worker Isolate in a node. The Isolate is spawned, without local isolate system, as a part of an isolate system running in another node. This functionality expands the isolate system beyond a physical system, as the isolate system can deploy number of instances of an isolate in several different nodes.
  An Isolate Deployer running in a remote machine can handle requests from multiple ‘Proxy Workers’ from other systems. Each ‘Proxy Worker’ opens up a separate WebSocket channel with the Isolate Deployer.

\section{Key Features}
\subsection{Hot Deployment of Isolates and Isolate Systems}
It is possible for the source code, of an isolate, to reside in a remote repository and fetched by the controller of a node when required. For instance: isolate source code can reside in a git repository hosted in GitHub. So that as soon as new code is committed in the repository, it gets immediately picked up by the application and the change gets reflected without restarting the application.
After a Virtual Machine is bootstrapped, changes like: addition, update or removal of isolates in an isolate system can take place. In such case, the isolates can be killed and redeployed when it has finished processing tasks and is sitting idle. A dedicated isolate monitors changes in the code repository. When a change is detected, the ‘FileMonitor’ isolate sends a special message to notify the controller that spawned it. The registry takes care of pushing the message to relevant controllers, and the controllers then take care of restarting or removing isolates.
This hot deployment capability increases the availability of an application. Whenever there is any change in a component of an application, the whole application does not need to be re-deployed, instead, only the set of isolates that should be updated can be restarted at runtime. This increases overall up-time of the application and keeps other components working even in the time of modification.

\subsection{Migration of Isolates and Isolate Systems}
Relocation of Isolates or an IsolateSystem during runtime i.e. killing a set of Isolates or an Isolate System at one location and bringing up same set of Isolates in another location is the migration of Isolates or Isolate System. The concept of hot deployment and migration brings enormous possibilities in a distributed system. Mostly it improves the availability of the system. Some of them are listed below:
\begin{itemize}
  \item Migration of actors/isolates allows an application to scale in an easy way. With this capability an application can bring up the most frequently used isolates near to the server where it is accessed the most.
  \item Related and dependent isolates can be migrated to the same server, if it is evident that it improves performance of the entire system.
  \item In case of hardware failure on a system which is running a certain set of isolates, migration of actors during runtime can make the application survive the hardware failure.

\end{itemize}
\subsection{Remote Isolates}
The Isolates in Dart lack functionality of communicating with remote isolates over a network. The isolates in this framework have an ability to communicate with the isolates that may be running in some remote Virtual Machine. So, there can be isolates running in any node. The communication underneath is taken care of by the framework and the implementer who is using this framework does not have to worry if an isolate is remotely spawned or locally spawned.
Because of the ability to spawning an isolate in. Two isolates, although, running in two different virtual machines, can still belong to same logical isolate system.

\section{Typical Message Flow in the System}
The framework is based on ‘fire-and-forget’ principle of message sending.
The message is serialized before sending via a SendPort of an Isolate.

\subsection{Enqueuing a Message}
Sample format of message at different levels:

Extension of Worker: “Test” - A string

Worker:
{senderType: senderType.worker, id: mysystem/producer/88f52440-5060-11e4-f396-97cebb949945, action: action.send, payload: {sender: mysystem/producer, to: mysystem/consumer, message: Test, replyTo: null}}

Router:
{senderType: senderType.router, id: mysystem/producer, action: action.send, payload: {sender: mysystem/producer, to: mysystem/consumer, message: Test, replyTo: null}}

Controller:
{senderType: senderType.controller, id: mysystem/producer, action: action.send, payload: {sender: mysystem/producer, to: mysystem/consumer, message: Test, replyTo: null}}

IsolateSystem:
{targetQueue: mysystem.consumer, action: action.enqueue, payload: {sender: mysystem/producer, message: Test, replyTo: null}}

MessageQueuingSystem:

Enqueuer:


\subsection{Dequeuing a Message}
Sample format of message at different levels:
Dequeuer:
Message Queuing System:
IsolateSystem:
Controller:
Router:
Worker:
Extension of Worker:

\subsection{Sending a Message}
To send a message from one Worker Isolate to another, simply the ‘send’ function can be invoked. The ‘send’ function takes ‘message’ and ‘address’ of the target isolate as its argument. The reply path can also be optionally set, so that the replied message from target isolate is sent to totally different actor for further processing. The named parameter ‘replyTo’ can be used with the address of actor that is supposed to received the replied message.

\subsection{Asking for a Reply}
Sometime the Isolate might just need a reply from another Isolate for further processing or before replying to the sender of the message. In such case, the Isolate can specifically ask the target isolate to reply to this particular instance of Isolate.
For instance, a sample use case can be, when an Isolate is maintaining a port connection with a browser. As the port cannot be serialized and passed around through messages, another instance of similar isolate will not be able to serve the reply for the request made through that particular port.

\subsection{Replying to a Message}

\subsection{Control Messages}
As the current implementation of Isolates in Dart does not provide the features to send the control messages like KILL, PING, RESTART. Although, it is not implemented yet, as these features are mentioned in documentation of
\subsubsection{KILL}
\subsubsection{RESTART}
\subsubsection{PING}

\subsection{Some Implementation Overview}
  Some insight about the message structure to explain how stuffs work in the framework:
  \begin{description}
    \item How SEND works?
      When a Worker Isolate sends a message using ‘send’ function of the Worker class, the message is encapsulated and further information about sender and receiver are added to the message. The message is sent to the spawner, which in this case is the ‘Router’. The router agains forwards it to ‘Controller’ which again forwards to the top level isolate \textendash{} IsolateSystem. The Isolate System adds another level of encapsulation and information about queue name, in which queue it should be enqueued, to the message so that the Message Queuing System knows the destination queue.
      If the Worker Isolate is expecting to consume another message after sending a message, it should send a PULL Request for another message, which can be performed by invoking the ‘done’ function.

    \item How ASK works?
    Ask function has certain subtle differences from the ‘send’ function. The ‘ask’ function should be used when the sender of the message expects something in reply. The Worker class adds the full path of the isolate along with the unique-id of the isolate when an ‘ask’ message is constructed. This is to make sure that the response from the target isolate reaches this particular instance of the isolate. The Router, which can also be called a load balancer, when receives a message with full address of isolate, routes the message to the isolate with the unique-id contained in the message. The message is simply discarded by the Router, if the isolate with the given unique-id is not found in the list of isolates the Router is maintaining. This is possible when the isolates have been restarted or for some reason the isolate was killed.

    \item How REPLY works?
    The ‘reply’ function is simply a convenience for the implementer. The ‘reply’ function simply invokes ‘send’ message with the sender’s address as the target isolate. If the message contains ‘replyTo’ then the message will be replied to the address contained in ‘replyTo’ instead of the original sender. The ‘reply’ function can be used to reply message in both \textendash{} ‘send’ and ‘ask’ cases.

    \item How Kill works?
    The is a special control message sent to the isolates as well as isolate system to shutdown themselves. If a KILL message is sent to an Isolate, the message is queued at the last of the isolate, (no futher messages after KILL message? in isolate level or router level, check code ! I think the router buffers the messages until the isolates are restarted and start sending them again once they come back up). Once it finishes processing the already queued messages and encounters the KILL message, the isolate closes its ReceivePort\footnote{A Worker Isolate receives message from Router via a ReceivePort} and sits idle. After sometime it gets Garbage Collected and cleaned up. However, the implementation is slightly different because even after waiting an isolate to be Garbage Collected, the memory sometimes does not get freed up as expected. As a workaround for this, the isolate made to throw a custom Exception when it receives KILL message. This way it is sure to get shutdown forcefully and the memory it kept occupying gets freed.

    \item How Restart works?
    Restarting and Isolate is basically killing an isolate and spawning it up again. However, during restart, the messages that arrive to the router after issuing the KILL message, are buffered in the router itself. The buffered messages are flushed and sent out once the Worker isolates are spawned. For instance, when the ‘HotDeployment’ feature is enabled during the time of deploying an Isolate in an Isolate System, if the source code of the isolate is modified and saved, then the each of the isolates that the router has spawned gets restarted. During which messages that arrive after RESTART message are buffered in the router.

    \item How Shutdown IsolateSystem works?
    An Isolate System that is running in a node can be shutdown via Web Interface or via POST request to the Registry. When a request to shutdown a complete IsolateSystem is sent, the IsolateSystem closes all the ports including the WebSocket connection with Message Queuing System and the forceful shutdown is carried out by throwing out and Exception as a workaround to free up the memory consumed after it is shutdown.

  \end{description}
\subsection{Clustering}
Clustering can be achieved in the framework by deploying replicas of an isolate system in different nodes. Where each node can be either be connected to same MQS or differnt instance of the MQS.
[?Further, the MQS can again be connected to same instance of a Message Broker System of another instance of the Message Broker System but belongs to same cluster.]

\section{Dart Libraries Used in Construction}
  \subsection{STOMP}
  \subsection{Path}
  \subsection{}

\section{A Sample Implementation of Worker using the Framework}
\begin{lstlisting}[language=java,firstnumber=1]
    import 'dart:isolate';
    import 'package:isolatesystem/worker/Worker.dart';

    main(List<String> args, SendPort sendPort) {
      Consumer printerIsolate = new Consumer(args, sendPort);
    }

    class Consumer extends Worker {
      Consumer(List<String> args, SendPort sendPort) : super(args, sendPort);

      @override
      onReceive(message) {
        switch(message['action']) {
          case "print":
            print("message['content']");
            break;
          case "send_back":
            reply(message['content']);
            break;
        }
        done();
      }
    }

\end{lstlisting}
